{{- $term := .Inner | markdownify -}}

{{- $filename := .Get "file" -}}   <!-- 使用方式：file="llm.md" 或 file="taylor.md" -->

{{- if not $filename -}}
  {{- errorf "term-modal 需要 file 参数，例如 file=\"llm.md\"" .Position -}}
{{- end -}}

<!-- 在 assets/md/ 目录下查找文件 -->
{{- $mdResource := resources.Get (printf "md/%s" $filename) -}}

{{- if not $mdResource -}}
  {{- errorf "在 assets/md/ 下找不到文件：%s" $filename -}}
{{- end -}}

<!-- 获取渲染后的 HTML 内容 -->
{{- $rendered := $mdResource.Content | markdownify | safeHTML -}}

<!-- 生成唯一 ID -->
{{- $id := printf "term-modal-%s" (md5 $filename) -}}

<!-- 触发器：使用 sup 星星，避免换行问题 -->
<span class="term-modal-trigger" 
      data-modal-id="{{ $id }}"
      data-content="{{ $rendered | base64Encode }}">   <!-- base64 编码传递渲染结果 -->
  <span class="term-text">{{ $term }}<sup class="term-star">★</sup></span>
</span>

<script>
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('.term-modal-trigger').forEach(trigger => {
    const modalId = trigger.dataset.modalId;
    const encoded = trigger.dataset.content;

    trigger.addEventListener('click', (e) => {
      e.preventDefault();

      let modal = document.getElementById(modalId);
      if (modal) {
        modal.style.display = 'block';
        return;
      }

      modal = document.createElement('div');
      modal.id = modalId;
      modal.className = 'term-modal';
      modal.innerHTML = `
        <div class="term-modal-content">
          <span class="term-modal-close">&times;</span>
          <div class="term-modal-body"></div>
        </div>
      `;
      document.body.appendChild(modal);

      const body = modal.querySelector('.term-modal-body');
      const closeBtn = modal.querySelector('.term-modal-close');

      closeBtn.addEventListener('click', () => modal.style.display = 'none');
      modal.addEventListener('click', ev => {
        if (ev.target === modal) modal.style.display = 'none';
      });
	// base64 → binary string → Uint8Array → UTF-8 解码
let binary = atob(encoded);
let len = binary.length;
let bytes = new Uint8Array(len);
for (let i = 0; i < len; i++) {
  bytes[i] = binary.charCodeAt(i);
}
const decoder = new TextDecoder('utf-8');
const content = decoder.decode(bytes);

      body.innerHTML = content;

      // MathJax 重新渲染
      if (typeof MathJax !== 'undefined') {
        MathJax.typesetPromise([body]).catch(err => {
          console.error('MathJax typeset failed:', err);
        });
      } else if (MathJax && MathJax.Hub) {
        MathJax.Hub.Queue(["Typeset", MathJax.Hub, body]);
      }

      modal.style.display = 'block';
    });
  });
});
</script>
